<wiki:toc>

= Mapping multiple XML elements to a {{{Collection}}} =

Xmappr can map multiple XML elements to a subtype of {{{java.util.Collection}}}.

{{{
<root>
  <number>1</number>
  <number>2</number>
  <number>3</number>
</root>
}}}

can be mapped to a {{{java.util.Collection}}} like this:

{{{
@RootElement
class Root{

  @Element(targetType=Integer.class)
  List number;
}
}}}

Here Xmappr will take every {{{<number>}}} element, convert it to {{{Integer}}} and add it to an instance of {{{ArrayList}}}.

Xmappr normally derives target type from field type, but since Java generics' type erasure removes runtime type information, an alternative way for providing type information has to be used. This is the job of {{{targetType}}} attribute of the {{{@Element}}} annotation. When a target field is a {{{Collection}}} this attribute must be provided, otherwise an exception is thrown. 

== Mapping different elements to a {{{Collection}}} ==

Sometimes different XML elements must be mapped to the same {{{Collection}}}:

{{{
<root>
  <one>1</one>
  <two>2.2</two>
  <three>Three</three>
</root>
}}} 

are mapped to:

{{{
@RootElement
class Root{

  @Elements({
    @Element(name="one", targetType=Integer.class),
    @Element(name="two", targetType=Double.class),
    @Element(name="three", targetType=String.class)
  })
  List number;
}
}}}

The {{{@Elements}}} annotation wraps multiple {{{@Element}}} annotations so that multiple mappings can be defined on one {{{Collection}}}. Every {{{@Element}}} mapping can have it's own target type or converter defined.

== Wildcard mapping ==

When there are a lot of different XML subelements, they can all be mapped to a single {{{java.util.Collection}}} with one {{{@Element}}} line. 

Given the above XML snippet a wildcard mapping can be done like this:

{{{
@RootElement
class Root{

  @Element("*")
  List number;
}
}}}

Here all subelements of the {{{<root>}}} element will be mapped to the {{{number}}} field. When using wildcard element names the default converter is {{{DomElementConverter}}}, so all matched elements will be converted to {{{DomElement}}} instances.  

*NOTE:* Wildcard name {{{"*"}}} is a special name and NOT a regular expression. Things like {{{"*a"}}} are not possible and will not work.

=== Mixing different mappings ===

It's also possible to mix-and-match named {{{@Element}}}s and wildcard {{{@Element}}}s:

{{{
@RootElement
class Root{

  @Elements({
    @Element(name="one", targetType=Integer.class),
    @Element("*")
  })
  List number;
}
}}}

Element {{{<one>}}} will be converted to {{{Integer}}}, while {{{<two>}}} and {{{<three>}}} will be converted to {{{DomElement}}}.
 
=== With custom converter ===
A custom target type or converter can be assigned to wildcard mappings:

{{{
@RootElement
class Root{

  @Element(name="*", targetType=String.class)
  List numbers;
}
}}}

In this case all XML elements will be converted to {{{String}}}s and added to the {{{numbers}}} list.

= Mapping multiple XML attributes to a {{{Collection}}} =